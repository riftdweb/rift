import { deriveChildSeed, genKeyPairAndSeed, genKeyPairFromSeed, hashDataKey, hashRegistryEntry } from "./crypto";
import { stringToUint8ArrayUtf8, toHexString } from "./utils/string";

describe("deriveChildSeed", () => {
  it("should correctly derive a child seed", () => {
    // Hard-code expected values to catch any breaking changes.

    const masterSeed = "c1197e1275fbf570d21dde01a00af83ed4a743d1884e4a09cebce0dd21ae254c";
    const seed = "seed";
    const expected = "6140d0d1d8f9e2b759ca7fc96ad3620cd382189f8d46339737e26a2764122b99";

    const childSeed = deriveChildSeed(masterSeed, seed);
    expect(childSeed).toEqual(expected);

    const seed1 = deriveChildSeed(masterSeed, "asd");
    const seed2 = deriveChildSeed(masterSeed, "aa");
    const seed3 = deriveChildSeed(masterSeed, "ds");
    expect(seed1).not.toEqual(seed2);
    expect(seed2).not.toEqual(seed3);
  });
});

describe("genKeyPairAndSeed", () => {
  it("should create a seed of the given length, hex-encoded", () => {
    const length = 8;
    const { seed } = genKeyPairAndSeed(length);
    // The length is specified in bytes and seed.length gives us the length of
    // the string representation of the seed bytes, which is hex encoded.
    expect(seed.length).toEqual(length * 2);
  });
});

describe("genKeyPairFromSeed", () => {
  it("should create an expected keypair from a given seed", () => {
    // Hard-code expected values to catch any breaking changes.
    const seed = "c1197e1275fbf570d21dde01a00af83ed4a743d1884e4a09cebce0dd21ae254c";
    const expectedPublicKey = "f8a7da8324fabb9d57bb32c59c48d4ba304d08ee5f1297a46836cf841da71c80";
    const expectedPrivateKey =
      "c404ff07fba961000dfb25ece7477f45b109b50a5169a45f3fb239343002c1cff8a7da8324fabb9d57bb32c59c48d4ba304d08ee5f1297a46836cf841da71c80";

    const { publicKey, privateKey } = genKeyPairFromSeed(seed);
    expect(publicKey).toEqual(expectedPublicKey);
    expect(privateKey).toEqual(expectedPrivateKey);
  });
});

describe("hashDataKey", () => {
  const keys = [
    ["", "81e47a19e6b29b0a65b9591762ce5143ed30d0261e5d24a3201752506b20f15c"],
    ["skynet", "31c7a4d53ef7bb4c7531181645a0037b9e75c8b1d1285b468ad58bad6262c777"],
  ];

  it.each(keys)("should correctly hash key %s as %s", (input: string, hash: string) => {
    expect(toHexString(hashDataKey(input))).toEqual(hash);
  });
});

describe("hashRegistryValue", () => {
  it("should match siad for equal input", () => {
    // Hard-code expected values to catch any breaking changes.

    // "h" is the hash generated by siad with the same input parameters
    const h = "788dddf5232807611557a3dc0fa5f34012c2650526ba91d55411a2b04ba56164";
    const hash = hashRegistryEntry(
      {
        dataKey: "HelloWorld",
        data: stringToUint8ArrayUtf8("abc"),
        revision: BigInt(123456789),
      },
      false
    );

    expect(toHexString(hash)).toEqual(h);
  });

  it("should match siad for equal input when data key and data include unicode", () => {
    // Hard-code expected values to catch any breaking changes.

    // "h" is the hash generated by siad with the same input parameters
    const h = "ff3b430675a0666e7461bc34aec9f66e21183d061f0b8232dd28ca90cc6ea5ca";
    const hash = hashRegistryEntry(
      {
        dataKey: "HelloWorld π",
        data: stringToUint8ArrayUtf8("abc π"),
        revision: BigInt(123456789),
      },
      false
    );

    expect(toHexString(hash)).toEqual(h);
  });

  it("hashing registry entry with hashed vs non-hashed datakeys should result in different outputs", () => {
    const hash1 = hashRegistryEntry(
      {
        dataKey: "abcd",
        data: stringToUint8ArrayUtf8("abc π"),
        revision: BigInt(123456789),
      },
      false
    );

    const hash2 = hashRegistryEntry(
      {
        dataKey: "abcd",
        data: stringToUint8ArrayUtf8("abc π"),
        revision: BigInt(123456789),
      },
      true
    );

    expect(toHexString(hash1)).not.toEqual(toHexString(hash2));
  });
});
